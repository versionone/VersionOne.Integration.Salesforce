//TODO
// create parser for exceptions from the VersionOne, atm we just put xml to log
global with sharing class V1Publisher {

    global static final String URL_TO_V1_TEMPLATE = 'assetdetail.v1?oid=';

    global static IV1Connector connector {set;get;}
    global static Settings settings {set;get;}

    /** Lazy initialized map of projects (Name->ID). */
    private Map<String, String> projects;
    /** Lazy initialized list of casses need to be published. */
    private List<Case> cases;
    /** Lazy initialized map of casses which was already published (CaseID->?). */
    private Map<String, Boolean> publishedCases;

    @future (callout=true)
    public static void publish() {
        if (init()) {
            try {
                V1Publisher pub = new V1Publisher();
                pub.processCases();
            } catch (Exception ex) {
                errorMessage('Problems during getting existed defects from the VersionOne.', ex);
                return;
            }
        }
    }

    /** Initialize settings and connector, check whether settings are correct. */
    public static Boolean init() {
        if (settings == null) {
            settings = new Settings();
        }
        if (connector == null) {
            connector = new V1Connector(settings, new Requestor(settings));
        }
        if (!settings.isValid()) {
            errorMessage('Incorrect settings.');
            return false;
        }
        if (settings.getSourceId() == null) {
            errorMessage('Source ' + settings.getSource() + ' not found in VersionOne. Cases can\'t be ported to VersionOne.');
            return false;
        }
        return true;
    }

    public Map<String, String> getProjects() {
        if (projects == null) {
            projects = connector.findAllProjects();
        }
        return projects;
    }

    public Case[] getCasesToPublish() {
        if (cases == null) {
            List<Case> res = V1CaseCollector.getCasesByOwnerId(settings.getDefectQueueId());
            res.addAll(V1CaseCollector.getCasesByOwnerId(settings.getStoryQueueId()));
            cases = res;
        }
        return cases;
    }

    public Map<String, Boolean> getPublishedCases() {
        if (publishedCases == null) {
            if (getCasesToPublish().size() == 0) {
                publishedCases = new Map<String, Boolean>();
            } else {
                publishedCases = connector.getReferencedWorkitems(cases);
            }
        }
        return publishedCases;
    }

    /** Processes cases assigned to settings.getSourceQueueId() queue and update that cases. **/
    public void processCases() {
        List<Case> updateCase = new List<Case>();
        List<String> updateId = new List<String>();
        for (Case caseData : getCasesToPublish()) {
            if (!canMakeCallouts(2)) {
               break;
            }
            updateId.add(processCase(caseData));
            updateCase.add(caseData);
        }
        System.debug('PROCESSED, UPDATING\n' + updateCase + '\n' + updateId);
        for (Integer i = 0; i < updateCase.size(); i++) {
            Case caseData = updateCase[i];
            String v1id = updateId[i];
            String url = (v1id == null) ? null : settings.getPath() + URL_TO_V1_TEMPLATE + EncodingUtil.urlEncode(v1id, 'UTF-8');
            V1CaseCollector.updateCase(caseData, settings.getDestQueueId(), settings.getCommentBody(), url, false);
        }
    }

    public Boolean canMakeCallouts(Integer count) {
        System.debug('Limits.getCallouts()='+Limits.getCallouts());
        System.debug('Limits.getLimitCallouts()='+Limits.getLimitCallouts());
        return Limits.getCallouts() + count <= Limits.getLimitCallouts();
    }

    /** Returns id of created workitem or null if workitem wsa already created. */
    public String processCase(Case caseData) {
        System.debug(caseData);
        if (getPublishedCases().containsKey(caseData.CaseNumber)) {
            errorMessage('Case "' + caseData.Subject + '" (' + caseData.CaseNumber +') was already ported.' );
            return null;
        } else {
            String projectId = findProjectId(caseData.VersionOneProject__c);
            return createDataInVersionOne(caseData, projectId);
        }
    }

    /** return id created woritem or null in case any errors */
    public String createDataInVersionOne(Case caseData, String projectId) {
        String id;
        try {
            id = connector.createWorkitemInV1(caseData, projectId);
        } catch (Exception ex) {
            //here need to restore mark about processing
        }
        connector.createLinkV1ToSF(id, caseData);
        return id;
    }

    /** Returns project id by project name. **/
    public String findProjectId(String projectName) {
        if (getProjects().containsKey(projectName)) {
            return getProjects().get(projectName);
        }
        return connector.getDefaultProjectId();
    }

    /** Logs error message. **/
    public static void errorMessage(String message) {
        System.debug(message);
    }

    /** Logs error message with exception. **/
    public static void errorMessage(String message, Exception ex) {
        System.debug(message + '/n' + ex);
    }

    public static Map<String, String> getFutureCurrentFuture() {
        String jobType = 'future';
        String methodName = 'publish';
        String[] statuses = new String[]{'Queued', 'Processing'};
        AsyncApexJob aaj;
        try {
            aaj = [SELECT Id, Status, NumberOfErrors
                FROM AsyncApexJob WHERE
                    JobType =: jobType AND
                    MethodName =: methodName AND
                    Status in: statuses];
        } catch (QueryException ex) {
            // no current future was ran
            return null;
        }

        Map<String, String> futureData = new Map<String, String>();
        futureData.put('Status', aaj.Status);
        futureData.put('NumberOfErrors', String.valueof(aaj.NumberOfErrors));

        return futureData;
    }

    public static Boolean isFutureRan() {
        Map<String, String> futureData = getFutureCurrentFuture();
        if (futureData == null) {
            return false;
        }
        return futureData.get('Status') == 'Queued' || futureData.get('Status') == 'Processing';
    }
}